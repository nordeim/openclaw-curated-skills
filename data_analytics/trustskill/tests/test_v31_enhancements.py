#!/usr/bin/env python3
"""
TrustSkill v3.1 Enhancement Validation Tests

Tests for:
1. NPM Integrity Hash Whitelist
2. Download vs Upload Detection
3. Context-Aware Documentation Scanning
"""

import sys
import os
import tempfile
import shutil
from pathlib import Path

script_dir = Path(__file__).parent.parent / "src"
sys.path.insert(0, str(script_dir.parent))

from src.types import AnalysisMode
from src.scanner import SkillScanner
from src.analyzers.secret_analyzer import (
    SecretAnalyzer,
    LOCK_FILES,
    INTEGRITY_HASH_PATTERN,
)
from src.analyzers.regex_analyzer import RegexAnalyzer


class TestResult:
    def __init__(self, name: str, passed: bool, message: str = ""):
        self.name = name
        self.passed = passed
        self.message = message

    def __str__(self):
        status = "‚úÖ PASS" if self.passed else "‚ùå FAIL"
        return f"{status}: {self.name}" + (f" - {self.message}" if self.message else "")


def test_integrity_hash_whitelist():
    """Test that NPM integrity hashes are not flagged as secrets."""
    results = []

    # Test 1: package-lock.json with integrity hashes
    with tempfile.TemporaryDirectory() as tmpdir:
        tmpdir = Path(tmpdir)

        # Create a package-lock.json with integrity hashes
        lock_content = """{
  "name": "test-package",
  "lockfileVersion": 3,
  "packages": {
    "node_modules/lodash": {
      "version": "4.17.21",
      "resolved": "https://registry.npmjs.org/lodash/-/lodash-4.17.21.tgz",
      "integrity": "sha512-v2kDEe57lecTulaDIuNTPy3Ry4gLGJ6Z1O3vE1krgXZNrsQ+LFTGHVxVjcXPs17LhbZVGedAJv8XZ1tvj5FvSg=="
    }
  }
}"""
        (tmpdir / "package-lock.json").write_text(lock_content)

        analyzer = SecretAnalyzer(AnalysisMode.STANDARD)
        issues = analyzer.analyze(tmpdir / "package-lock.json", lock_content)

        passed = len(issues) == 0
        results.append(
            TestResult(
                "Integrity hash in package-lock.json not flagged",
                passed,
                f"Found {len(issues)} issues (expected 0)",
            )
        )

    # Test 2: yarn.lock with integrity hashes
    with tempfile.TemporaryDirectory() as tmpdir:
        tmpdir = Path(tmpdir)

        yarn_content = """# THIS IS AN AUTOGENERATED FILE
lodash@^4.17.21:
  version "4.17.21"
  resolved "https://registry.yarnpkg.com/lodash/-/lodash-4.17.21.tgz#679b1c562c6d9c3c7d9c6b1e2a4c2d1e2c3b4a5e"
  integrity sha512-v2kDEe57lecTulaDIuNTPy3Ry4gLGJ6Z1O3vE1krgXZNrsQ+LFTGHVxVjcXPs17LhbZVGedAJv8XZ1tvj5FvSg==
"""
        (tmpdir / "yarn.lock").write_text(yarn_content)

        analyzer = SecretAnalyzer(AnalysisMode.STANDARD)
        issues = analyzer.analyze(tmpdir / "yarn.lock", yarn_content)

        passed = len(issues) == 0
        results.append(
            TestResult(
                "Integrity hash in yarn.lock not flagged",
                passed,
                f"Found {len(issues)} issues (expected 0)",
            )
        )

    # Test 3: Regular Python file with real secret SHOULD still be flagged
    with tempfile.TemporaryDirectory() as tmpdir:
        tmpdir = Path(tmpdir)

        py_content = """
API_KEY = "sk-realapikey123456789012345678901234"
password = "SuperSecretPassword123!"
"""
        (tmpdir / "config.py").write_text(py_content)

        analyzer = SecretAnalyzer(AnalysisMode.STANDARD)
        issues = analyzer.analyze(tmpdir / "config.py", py_content)

        passed = len(issues) > 0
        results.append(
            TestResult(
                "Real secrets in Python file ARE flagged",
                passed,
                f"Found {len(issues)} issues (expected > 0)",
            )
        )

    return results


def test_download_vs_upload_detection():
    """Test that downloads are handled differently from uploads."""
    results = []

    # Test 1: urlretrieve (download) should be MEDIUM risk, not HIGH
    with tempfile.TemporaryDirectory() as tmpdir:
        tmpdir = Path(tmpdir)

        py_content = """
import urllib.request

# Download a PDF from arxiv
urllib.request.urlretrieve("https://arxiv.org/pdf/1234.pdf", "local.pdf")
"""
        (tmpdir / "download.py").write_text(py_content)

        scanner = SkillScanner(AnalysisMode.STANDARD)
        result = scanner.scan(str(tmpdir))

        # Check that we have data_download, not data_exfiltration or data_upload
        has_download = any(f.category == "data_download" for f in result.findings)
        has_upload = any(f.category == "data_upload" for f in result.findings)
        has_exfil = any(f.category == "data_exfiltration" for f in result.findings)

        # urlretrieve should be flagged as download (MEDIUM), not upload (HIGH)
        passed = has_download or (not has_upload and not has_exfil)
        results.append(
            TestResult(
                "urlretrieve flagged as download, not upload",
                passed,
                f"download={has_download}, upload={has_upload}, exfil={has_exfil}",
            )
        )

    # Test 2: requests.post with data should be HIGH risk
    with tempfile.TemporaryDirectory() as tmpdir:
        tmpdir = Path(tmpdir)

        py_content = """
import requests

# Sending data to external server
response = requests.post("https://example.com/api", data={"secret": "value"})
"""
        (tmpdir / "upload.py").write_text(py_content)

        scanner = SkillScanner(AnalysisMode.STANDARD)
        result = scanner.scan(str(tmpdir))

        has_upload = any(f.category == "data_upload" for f in result.findings)
        has_high = any(f.level.value == "HIGH" for f in result.findings)

        passed = has_upload or has_high
        results.append(
            TestResult(
                "requests.post flagged as upload (HIGH)",
                passed,
                f"upload={has_upload}, high={has_high}",
            )
        )

    return results


def test_documentation_context():
    """Test that documentation examples are not flagged."""
    results = []

    # Test 1: SKILL.md with placeholder API key
    with tempfile.TemporaryDirectory() as tmpdir:
        tmpdir = Path(tmpdir)

        md_content = """# My Skill

## Configuration

Set your API key:
```bash
export API_KEY="your_api_key_here"
```

Or in Chinese:
```bash
export API_KEY="‰Ω†ÁöÑÂØÜÈí•"
```
"""
        (tmpdir / "SKILL.md").write_text(md_content)

        scanner = SkillScanner(AnalysisMode.STANDARD)
        result = scanner.scan(str(tmpdir))

        # Should not flag documentation placeholders
        has_api_key_flag = any("api_key" in f.category.lower() for f in result.findings)

        # Count issues - should be minimal or none
        issue_count = len(result.findings)

        passed = issue_count <= 1  # Allow minimal false positives
        results.append(
            TestResult(
                "Documentation placeholders not flagged",
                passed,
                f"Found {issue_count} issues in SKILL.md",
            )
        )

    # Test 2: README with shell config reference
    with tempfile.TemporaryDirectory() as tmpdir:
        tmpdir = Path(tmpdir)

        md_content = """# Setup

Add to your shell config:
```bash
# Add to ~/.bashrc or ~/.zshrc
export MY_API_KEY="your_key_here"
```
"""
        (tmpdir / "README.md").write_text(md_content)

        scanner = SkillScanner(AnalysisMode.STANDARD)
        result = scanner.scan(str(tmpdir))

        # Should not flag ~/.bashrc in documentation
        has_sensitive_access = any(
            f.category == "sensitive_file_access" for f in result.findings
        )

        passed = not has_sensitive_access
        results.append(
            TestResult(
                "Shell config reference in docs not flagged",
                passed,
                f"sensitive_file_access={has_sensitive_access}",
            )
        )

    # Test 3: Real code accessing sensitive files SHOULD still be flagged
    with tempfile.TemporaryDirectory() as tmpdir:
        tmpdir = Path(tmpdir)

        py_content = """
# This is real code, not documentation
with open("/home/user/.ssh/id_rsa", "r") as f:
    private_key = f.read()
"""
        (tmpdir / "malicious.py").write_text(py_content)

        scanner = SkillScanner(AnalysisMode.STANDARD)
        result = scanner.scan(str(tmpdir))

        has_issue = len(result.findings) > 0

        passed = has_issue
        results.append(
            TestResult(
                "Real SSH key access IS flagged",
                passed,
                f"Found {len(result.findings)} issues (expected > 0)",
            )
        )

    return results


def run_all_tests():
    """Run all validation tests."""
    print("=" * 60)
    print("TrustSkill v3.1 Enhancement Validation Tests")
    print("=" * 60)
    print()

    all_results = []

    print("üìã Test Suite 1: NPM Integrity Hash Whitelist")
    print("-" * 40)
    for result in test_integrity_hash_whitelist():
        print(f"  {result}")
        all_results.append(result)
    print()

    print("üìã Test Suite 2: Download vs Upload Detection")
    print("-" * 40)
    for result in test_download_vs_upload_detection():
        print(f"  {result}")
        all_results.append(result)
    print()

    print("üìã Test Suite 3: Context-Aware Documentation Scanning")
    print("-" * 40)
    for result in test_documentation_context():
        print(f"  {result}")
        all_results.append(result)
    print()

    # Summary
    passed = sum(1 for r in all_results if r.passed)
    total = len(all_results)

    print("=" * 60)
    print(f"SUMMARY: {passed}/{total} tests passed")
    print("=" * 60)

    if passed == total:
        print("‚úÖ All enhancements working correctly!")
        return 0
    else:
        print("‚ùå Some tests failed. Please review.")
        return 1


if __name__ == "__main__":
    sys.exit(run_all_tests())
