# Vulnerability Patterns — Condensed Reference

Sources: SCV-List (sirhashalot), Not So Smart Contracts (Trail of Bits/crytic)

## Classic Vulnerability Categories (Not So Smart Contracts)

### 1. Reentrancy
**Pattern:** External call before state update
```solidity
// VULNERABLE
function withdraw(uint amount) public {
    require(balances[msg.sender] >= amount);
    (bool success,) = msg.sender.call{value: amount}("");  // external call
    balances[msg.sender] -= amount;  // state update AFTER call
}
```
**Fix:** Checks-Effects-Interactions (CEI) + ReentrancyGuard
```solidity
function withdraw(uint amount) public nonReentrant {
    require(balances[msg.sender] >= amount);
    balances[msg.sender] -= amount;  // state update BEFORE call
    (bool success,) = msg.sender.call{value: amount}("");
}
```

### 2. Integer Overflow/Underflow
**Pattern:** Arithmetic without bounds checking (pre-Solidity 0.8)
```solidity
// VULNERABLE (pre-0.8)
uint8 balance = 255;
balance += 1;  // wraps to 0

uint balance2 = 0;
balance2 -= 1;  // wraps to 2^256-1
```
**Fix:** Solidity >=0.8.0 (built-in checks) or SafeMath. Watch `unchecked {}` blocks.

### 3. Unprotected Functions
**Pattern:** Missing access control on sensitive functions
```solidity
// VULNERABLE
function setOwner(address _owner) public {
    owner = _owner;  // anyone can call!
}
```
**Fix:** Add access control modifiers (onlyOwner, role-based)

### 4. Unchecked External Calls
**Pattern:** Not checking return value of low-level calls
```solidity
// VULNERABLE
payable(to).send(amount);  // returns false on failure, not checked
address(token).call(abi.encodeWithSignature("transfer(address,uint256)", to, amount));
```
**Fix:** Check return values, use SafeERC20, use `transfer()` for ETH (reverts)

### 5. Denial of Service
**Pattern:** Attacker makes contract function unusable
- Push-based payments where one recipient can revert and block all
- Unbounded loops that exceed gas limit
- External dependency failure blocks critical path
```solidity
// VULNERABLE - one bad recipient blocks all
for (uint i = 0; i < recipients.length; i++) {
    payable(recipients[i]).transfer(amounts[i]);  // reverts if one fails
}
```
**Fix:** Pull-based withdrawals, bounded loops, try/catch

### 6. Bad Randomness
**Pattern:** On-chain "randomness" from predictable sources
```solidity
// VULNERABLE
uint random = uint(keccak256(abi.encodePacked(block.timestamp, block.difficulty, msg.sender)));
```
**Fix:** Chainlink VRF, commit-reveal scheme

### 7. Front-running / Race Conditions
**Pattern:** Mempool-visible transactions exploited by MEV bots
- Token approve race condition
- DEX trades without slippage protection
- Contract deployment front-running
**Fix:** Commit-reveal, slippage bounds, deadline parameters

### 8. Forced Ether Reception
**Pattern:** Contract assumes `address(this).balance` == tracked deposits
```solidity
// VULNERABLE
require(address(this).balance == totalDeposits);  // can be broken by selfdestruct send
```
**Fix:** Use internal accounting, never rely on `address(this).balance`

### 9. Variable Shadowing
**Pattern:** Local/child variable hides parent variable
```solidity
contract Parent { uint public x = 1; }
contract Child is Parent {
    uint public x = 2;  // shadows Parent.x
}
```
**Fix:** Use unique names, check with Slither

### 10. Incorrect Interface
**Pattern:** Contract implements wrong function signature
```solidity
// Interface says: function transfer(address, uint) returns (bool)
// Implementation: function transfer(address, uint) returns (uint)  // WRONG
```
**Fix:** Use `interface` keyword, slither-check-erc

---

## Real-World Vulnerability Patterns (from SCV-List incidents)

### Donation/Inflation Attack (First Depositor)
**Seen in:** ERC4626 vaults, LP pools
**How:** First depositor deposits 1 wei, then donates large amount directly, inflating share price so next depositor gets 0 shares
**Fix:** Virtual shares/assets, minimum first deposit, dead shares

### Read-Only Reentrancy
**Seen in:** Curve `get_virtual_price()`, cross-protocol integrations
**How:** View function returns manipulated value during reentrancy callback
**Fix:** Extend reentrancy guard to view functions, don't trust external view functions during callbacks

### Uninitialized Proxy
**Seen in:** Aave, Arbitrum, Agave (forked code)
**How:** Implementation contract not initialized → attacker calls `initialize()` to take ownership
**Fix:** Call `_disableInitializers()` in constructor, initialize in same tx as deployment

### Oracle Manipulation via Spot Price
**Seen in:** Many DeFi protocols using pool ratios as price feeds
**How:** Flash loan to manipulate pool balance → skewed price → profit from dependent protocol
**Fix:** TWAP, Chainlink, multi-oracle with deviation checks

### Cross-Protocol Reentrancy
**Seen in:** Sherlock (via 1inch callback to Euler)
**How:** Callback during swap allows reentering different protocol that shares state
**Fix:** Global reentrancy locks across integrated protocols

### Duplicate/Replay in Merkle Claims
**Seen in:** Balancer merkle distributor
**How:** Merkle tree logic accepts duplicate leaf nodes, allowing multiple claims
**Fix:** Track claimed status per leaf, use nonces

### Missing Access Control on Price/State Setters
**Seen in:** Sense Finance, Aave fallback oracle, Talent Protocol
**How:** Anyone can call `setPrice()` or `setToken()` functions
**Fix:** Always add access control to state-changing functions

### Logic Error in Amount Calculation
**Seen in:** Synthetix, Yield Protocol, Beanstalk
**How:** Wrong variable used (e.g., gross amount instead of net), copy-paste from similar function
**Fix:** Thorough review of variable semantics, test with non-zero edge cases

### Signature Replay / Multisig Bypass
**Seen in:** Tron multisig
**How:** No check for duplicate signatures from same signer in multisig
**Fix:** Check signer uniqueness, enforce ascending signer order

### Chainlink / Oracle Stale Data
**Seen in:** Various lending protocols
**How:** Oracle returns stale price during downtime/congestion
**Fix:** Check `updatedAt` against heartbeat, implement circuit breakers, L2 sequencer checks

### Fee-on-Transfer Token Issues
**How:** Protocol assumes amount sent == amount received; actual received is less
**Fix:** Measure balance before/after transfer, not input amount

### Governance Flash Loan Attack
**How:** Borrow governance tokens → vote → return in same block
**Fix:** Snapshot-based voting, token lock during vote, time-weighted voting power
